import { cwd } from 'node:process';
import { extname, relative, dirname, basename, join } from 'node:path';
import { normalizePath } from 'vite';
import ora from 'ora';
import { cyan, gray } from 'colorette';
import { globby } from 'globby';
import { execa } from 'execa';
import { subtle } from 'uncrypto';
import GrayMatter from 'gray-matter';

function pathEquals(path, equals) {
  return normalizePath(path) === normalizePath(equals);
}
function pathStartsWith(path, startsWith) {
  return normalizePath(path).startsWith(normalizePath(startsWith));
}
function pathEndsWith(path, startsWith) {
  return normalizePath(path).endsWith(normalizePath(startsWith));
}
function createHelpers(root, id) {
  const relativeId = relative(root, id);
  return {
    pathStartsWith,
    pathEquals,
    pathEndsWith,
    idEndsWith(endsWith) {
      return pathEndsWith(relativeId, endsWith);
    },
    idEquals(equals) {
      return pathEquals(relativeId, equals);
    },
    idStartsWith(startsWith) {
      return pathStartsWith(relativeId, startsWith);
    }
  };
}
async function digestStringAsSHA256(message) {
  const msgUint8 = new TextEncoder().encode(message);
  const hashBuffer = await subtle.digest("SHA-256", msgUint8);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  return hashHex;
}
const defaultCommitURLHandler = (commit) => `${commit.repo_url}/commit/${commit.hash}`;
const defaultReleaseTagURLHandler = (commit) => `${commit.repo_url}/releases/tag/${commit.tag}`;
const defaultReleaseTagsURLHandler = (commit) => commit.tags?.map((tag) => `${commit.repo_url}/releases/tag/${tag}`);
async function returnOrResolvePromise(val) {
  if (!(val instanceof Promise))
    return val;
  return await val;
}
async function rewritePathsByPatterns(commit, path, patterns) {
  if (typeof patterns === "undefined" || patterns === null)
    return path;
  if ("handler" in patterns && typeof patterns.handler === "function") {
    const resolvedPath = await returnOrResolvePromise(patterns.handler(commit, path));
    if (!resolvedPath)
      return path;
    return resolvedPath;
  }
  return path;
}
function rewritePathsByRewritingExtension(from, to) {
  return (_, path) => {
    const ext = extname(path);
    if (ext !== from)
      return path;
    return path.replace(new RegExp(`${from}$`), to);
  };
}
function parseGitLogRefsAsTags(refs) {
  if (!refs)
    return [];
  const refsArray = refs.split(", ").map((ref) => ref.trim());
  const tags = refsArray.filter((ref) => ref.startsWith("tag: "));
  if (!tags)
    return [];
  return tags.map((tag) => tag.replace("tag: ", "").trim());
}
async function getRawCommitLogs(file, maxGitLogCount) {
  const fileDir = dirname(file);
  const fileName = basename(file);
  const format = "%H|%an|%ae|%ad|%s|%d|%b";
  const { stdout } = await execa("git", ["log", `--max-count=${maxGitLogCount ?? -1}`, `--format=${format}[GIT_LOG_COMMIT_END]`, "--follow", "--", fileName], { cwd: fileDir });
  return stdout.replace(/\[GIT_LOG_COMMIT_END\]$/, "").split("[GIT_LOG_COMMIT_END]\n");
}
function getRelativePath(file, srcDir, cwd) {
  cwd = normalizePath(cwd);
  return file.replace(srcDir, "").replace(cwd, "").replace(/^\//, "");
}
async function parseCommits(path, rawLogs, getRepoURL, getCommitURL, getReleaseTagURL, getReleaseTagsURL, optsRewritePathsBy) {
  rawLogs = rawLogs.filter((log) => !!log);
  const commits = await Promise.all(rawLogs.map(async (raw) => {
    const [hash, author_name, author_email, date, message, refs, body] = raw.split("|").map((v) => v.trim());
    const commit = {
      path,
      hash,
      date,
      date_timestamp: 0,
      message,
      body,
      author_name,
      author_email,
      author_avatar: ""
    };
    if (typeof optsRewritePathsBy !== "undefined")
      commit.path = await rewritePathsByPatterns(commit, commit.path, optsRewritePathsBy);
    commit.repo_url = await returnOrResolvePromise(getRepoURL(commit)) ?? "https://github.com/example/example";
    commit.hash_url = await returnOrResolvePromise(getCommitURL(commit)) ?? defaultCommitURLHandler(commit);
    const tags = parseGitLogRefsAsTags(refs?.replace(/[()]/g, ""));
    if (tags && tags.length > 0) {
      commit.tags = tags;
      commit.tag = commit.tags?.[0] || void 0;
      commit.release_tag_url = await returnOrResolvePromise(getReleaseTagURL(commit)) ?? defaultReleaseTagURLHandler(commit);
      commit.release_tags_url = await returnOrResolvePromise(getReleaseTagsURL(commit)) ?? defaultReleaseTagsURLHandler(commit);
    }
    commit.date_timestamp = new Date(commit.date).getTime();
    commit.author_avatar = await digestStringAsSHA256(commit.author_email);
    return commit;
  }));
  return commits;
}

const VirtualModuleID = "virtual:nolebase-git-changelog";
const ResolvedVirtualModuleId = `\0${VirtualModuleID}`;
const logModulePrefix = `${cyan(`@nolebase/vitepress-plugin-git-changelog`)}${gray(":")}`;
function GitChangelog(options = {}) {
  if (!options)
    options = {};
  const {
    cwd: cwd$1 = cwd(),
    maxGitLogCount,
    include = ["**/*.md", "!node_modules"],
    repoURL = "https://github.com/example/example",
    getReleaseTagURL = defaultReleaseTagURLHandler,
    getReleaseTagsURL = defaultReleaseTagsURLHandler,
    getCommitURL = defaultCommitURLHandler,
    rewritePathsBy
  } = options;
  const getRepoURL = typeof repoURL === "function" ? repoURL : () => repoURL;
  const changelog = { commits: [] };
  const hotModuleReloadCachedCommits = {};
  let srcDir = "";
  let config;
  const commitFromPath = async (path) => {
    const rawLogs = await getRawCommitLogs(path, maxGitLogCount);
    const relativePath = getRelativePath(path, srcDir, cwd$1);
    return await parseCommits(
      relativePath,
      rawLogs,
      getRepoURL,
      getCommitURL,
      getReleaseTagURL,
      getReleaseTagsURL,
      rewritePathsBy
    );
  };
  return {
    name: "@nolebase/vitepress-plugin-git-changelog",
    config: () => ({
      optimizeDeps: {
        include: [
          // @rive-app/canvas is a CJS/UMD module, so it needs to be included here
          // for Vite to properly bundle it.
          "@nolebase/vitepress-plugin-git-changelog > @nolebase/ui > @rive-app/canvas"
        ],
        exclude: [
          "@nolebase/vitepress-plugin-git-changelog/client"
        ]
      },
      ssr: {
        noExternal: [
          "@nolebase/vitepress-plugin-git-changelog",
          // @nolebase/ui required here as noExternal to avoid the following error:
          // TypeError [ERR_UNKNOWN_FILE_EXTENSION]: Unknown file extension ".vue" for ...
          // Read more here: https://github.com/vuejs/vitepress/issues/2915
          // And here: https://stackblitz.com/edit/vite-gjz9zf?file=docs%2F.vitepress%2Fconfig.ts
          "@nolebase/ui"
        ]
      }
    }),
    configResolved(_config) {
      config = _config;
      srcDir = config.vitepress.srcDir;
    },
    async buildStart() {
      if (config.command !== "build")
        return;
      const startsAt = Date.now();
      const spinner = ora({ discardStdin: false, isEnabled: false });
      spinner.start(`${logModulePrefix} Prepare to gather git logs...`);
      if (changelog.commits.length > 0)
        return;
      await execa("git", ["config", "--local", "core.quotepath", "false"]);
      spinner.text = `${logModulePrefix} Gathering git logs...`;
      spinner.color = "yellow";
      const paths = await globby(include, {
        gitignore: true,
        cwd: cwd$1,
        absolute: true
      });
      changelog.commits = (await Promise.all(
        paths.map(async (path) => await commitFromPath(path))
      )).flat();
      const elapsed = Date.now() - startsAt;
      spinner.succeed(`${logModulePrefix} Done. ${gray(`(${elapsed}ms)`)}`);
    },
    resolveId(id) {
      if (id === VirtualModuleID)
        return ResolvedVirtualModuleId;
    },
    load(id) {
      if (id !== ResolvedVirtualModuleId)
        return null;
      return `export default ${JSON.stringify(changelog)}`;
    },
    configureServer(server) {
      server.hot.on("nolebase-git-changelog:client-mounted", async (data) => {
        if (!data || typeof data !== "object")
          return;
        if (!("page" in data && "filePath" in data.page))
          return;
        let commits = [];
        if (hotModuleReloadCachedCommits[data.page.filePath]) {
          commits = hotModuleReloadCachedCommits[data.page.filePath];
        } else {
          const path = normalizePath(join(srcDir, data.page.filePath));
          commits = [...await commitFromPath(path)];
          hotModuleReloadCachedCommits[data.page.filePath] = commits;
        }
        if (!commits.length)
          return;
        const virtualModule = server.moduleGraph.getModuleById(ResolvedVirtualModuleId);
        if (!virtualModule)
          return;
        changelog.commits = commits;
        server.moduleGraph.invalidateModule(virtualModule);
        server.hot.send({
          type: "custom",
          event: "nolebase-git-changelog:updated",
          data: changelog
        });
      });
    }
  };
}

function GitChangelogMarkdownSection(options) {
  const {
    excludes = ["index.md"],
    exclude = () => false
  } = options ?? {};
  let root = "";
  return {
    name: "@nolebase/vitepress-plugin-git-changelog-markdown-section",
    // May set to 'pre' since end user may use vitepress wrapped vite plugin to
    // specify the plugins, which may cause this plugin to be executed after
    // vitepress or the other markdown processing plugins.
    enforce: "pre",
    configResolved(config) {
      root = config.root ?? "";
    },
    transform(code, id) {
      if (!id.endsWith(".md"))
        return null;
      const helpers = createHelpers(root, id);
      if (excludes.includes(relative(root, id)))
        return null;
      if (exclude(id, { helpers }))
        return null;
      const parsedMarkdownContent = GrayMatter(code);
      if ("nolebase" in parsedMarkdownContent.data && "gitChangelog" in parsedMarkdownContent.data.nolebase && !parsedMarkdownContent.data.nolebase.gitChangelog)
        return null;
      if ("gitChangelog" in parsedMarkdownContent.data && !parsedMarkdownContent.data.gitChangelog)
        return null;
      if (!options?.sections?.disableContributors)
        code = TemplateContributors(code);
      if (!options?.sections?.disableChangelog)
        code = TemplateChangelog(code);
      return code;
    }
  };
}
function TemplateContributors(code) {
  return `${code}

<NolebaseGitContributors />
`;
}
function TemplateChangelog(code) {
  return `${code}

<NolebaseGitChangelog />
`;
}

export { GitChangelog, GitChangelogMarkdownSection, rewritePathsByRewritingExtension };
//# sourceMappingURL=index.mjs.map

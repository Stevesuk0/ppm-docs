import { digestStringAsSHA256 } from "../utils.mjs";
export function findMapAuthorByName(mapContributors, author_name) {
  return mapContributors?.find((item) => {
    const res = item.mapByNameAliases && Array.isArray(item.mapByNameAliases) && item.mapByNameAliases.includes(author_name) || item.name === author_name;
    if (res)
      return true;
    return item.nameAliases && Array.isArray(item.nameAliases) && item.nameAliases.includes(author_name);
  });
}
export function findMapAuthorByEmail(mapContributors, author_email) {
  return mapContributors?.find((item) => {
    const res = item.mapByEmailAliases && Array.isArray(item.mapByEmailAliases) && item.mapByEmailAliases.includes(author_email);
    if (res)
      return true;
    return item.emailAliases && Array.isArray(item.emailAliases) && item.emailAliases.includes(author_email);
  });
}
export function findMapAuthorLink(creator) {
  if (!creator.links && !!creator.username)
    return `https://github.com/${creator.username}`;
  if (typeof creator.links === "string" && !!creator.links)
    return creator.links;
  if (!Array.isArray(creator.links))
    return;
  const priority = ["github", "twitter"];
  for (const p of priority) {
    const matchedEntry = creator.links?.find((l) => l.type === p);
    if (matchedEntry)
      return matchedEntry.link;
  }
  return creator.links?.[0]?.link;
}
const multipleAuthorsRegex = /^ *Co-authored-by: ?([^<]*)<([^>]*)> */gim;
export async function extractAuthorsWithMultiple(mapContributors, authorDataMap, c) {
  if (!c.body)
    return;
  let result;
  multipleAuthorsRegex.lastIndex = 0;
  while (result = multipleAuthorsRegex.exec(c.body)) {
    const [, name, email] = result;
    await mapCommitAuthors(mapContributors, authorDataMap, {
      author_name: name.trim(),
      author_email: email.trim(),
      author_avatar: await digestStringAsSHA256(email.trim())
    });
  }
}
export async function newAvatarForAuthor(mappedAuthor, commitAuthor) {
  if (mappedAuthor) {
    if (mappedAuthor.avatar)
      return mappedAuthor.avatar;
    if (mappedAuthor.username)
      return `https://github.com/${mappedAuthor.username}.png`;
  }
  if (commitAuthor.author_avatar)
    return `https://gravatar.com/avatar/${commitAuthor.author_avatar}?d=retro`;
  return `https://gravatar.com/avatar/${await digestStringAsSHA256(commitAuthor.author_email)}?d=retro`;
}
export async function mapCommitAuthors(mapContributors, map, commitAuthor) {
  const targetCreatorByName = findMapAuthorByName(mapContributors, commitAuthor.author_name);
  const targetCreatorByEmail = findMapAuthorByEmail(mapContributors, commitAuthor.author_email);
  let name = "";
  let avatar = "";
  let url;
  if (targetCreatorByName) {
    name = targetCreatorByName.name || commitAuthor.author_name;
    avatar = await newAvatarForAuthor(targetCreatorByName, commitAuthor);
    const foundSocialEntryUrl = findMapAuthorLink(targetCreatorByName);
    if (foundSocialEntryUrl)
      url = foundSocialEntryUrl;
  } else if (targetCreatorByEmail) {
    name = targetCreatorByEmail.name || commitAuthor.author_name;
    avatar = await newAvatarForAuthor(targetCreatorByEmail, commitAuthor);
    const foundSocialEntryUrl = findMapAuthorLink(targetCreatorByEmail);
    if (foundSocialEntryUrl)
      url = foundSocialEntryUrl;
  } else {
    name = commitAuthor.author_name;
    avatar = await newAvatarForAuthor(void 0, commitAuthor);
  }
  if (!map[name]) {
    map[name] = {
      name,
      commitsCount: 0,
      avatarUrl: avatar,
      url
    };
  }
  map[name].commitsCount++;
}
